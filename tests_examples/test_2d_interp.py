"""
Code to test speed and scalability of 2-D interpolation.

Specifically I am benchmarking my own zfun.interp_scattered on plaid()
with a nearest neighbor algorithm.
"""

import os, sys
sys.path.append(os.path.abspath('../../LiveOcean/alpha'))
import zfun

import numpy as np
import numpy.random as rand
from scipy.spatial import cKDTree
from time import time
import pandas as pd
import matplotlib.pyplot as plt

# user set parameters
N = 1000 # grid size

# make coordinates for plaid grid
xvec = np.linspace(0,1,N)
yvec = np.linspace(0,1,N)
# by going 0-1 the values generated by rand.random_sample naturally fall
# into the domain

# plaid grids
X, Y = np.meshgrid(xvec,yvec)

# data field to query at interpolation points
Z = X**2 + Y**2

# create the nearest neighbor Tree object
# (the speed of the method relies on doing this)
if False:
    # nan out a corner
    Z[:int(N/2), :int(N/2)] = np.nan
    Mask = ~np.isnan(Z)
    xy = np.array((X[Mask],Y[Mask])).T
    xyT = cKDTree(xy)
    ZZ = Z[Mask]
else:
    xy = np.array((X.flatten(),Y.flatten())).T
    xyT = cKDTree(xy)
    ZZ = Z.flatten()

# the goal here is to find the value of Z at a bunch of arbitrary x,y locations
# and then compare different ways of making this interpolation

# ASSUMES we are working with a plaid grid

# list of the number of particle positions to loop over
S_list = [100, 1000, 10000, 100000]
# and a DataFrame to store the results (the interpolation times)
df = pd.DataFrame(index=S_list, columns=['interp2','nearest'])

for S in S_list:
    
    # create random particle positions to interpolate Z to
    xs = rand.random_sample(S)
    ys = rand.random_sample(S)

    # (1) Use my zfun tools (bi-linear interpolation)
    tt0 = time()
    # note: zfun.interp_scattered_on_plaid() uses zfun.get_interpolant()
    zs = zfun.interp_scattered_on_plaid(xs, ys, xvec, yvec, Z)
    tt1 = time() - tt0

    # use nearest neighbor with the tree already created
    tt0 = time()
    xys = np.array((xs,ys)).T
    zs_alt = ZZ[xyT.query(xys, n_jobs=-1)[1]]
    tt2 = time() - tt0
    
    df.loc[S,'interp2'] = tt1
    df.loc[S,'nearest'] = tt2

    print('S = %10d: interp2 = %0.4f, nearest = %0.4f' % (S, tt1, tt2))

plt.close('all')
fig = plt.figure(figsize=(10,5))
ax1 = fig.add_subplot(121)
ax2 = fig.add_subplot(122)
df.plot(style='-o',ax=ax1)

ax2.plot(zs, zs_alt, '.c')
ax2.plot([0,2],[0,2],'-k')
plt.show()

